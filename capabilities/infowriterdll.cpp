// Info Writer DLL
// Compile Command: sudo x86_64-w64-mingw32-g++ -shared -o InfoWriterDll.dll infowriterdll.cpp -static-libgcc -static-libstdc++ -ldnsapi -lws2_32 -lnetapi32

#include <winsock2.h>
#include <windows.h> 
#include <ws2tcpip.h>
#include <windns.h>
#include <lm.h>
#include <fstream>
#include <cstring>

// Link with the required libraries.
#pragma comment(lib, "Dnsapi.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "Netapi32.lib")

#ifdef __cplusplus
extern "C" {
#endif

// Exported function that gathers system information, enumerates local users,
// and queries DNS for "hello.iamironcat.com". It writes all this information
// to the specified file. Returns 0 on success or a negative error code.
__declspec(dllexport) int WriteAllInfoToFile(const char* filename)
{
    if (filename == nullptr)
    {
        return -1; // Invalid parameter.
    }

    // Open the file for writing.
    std::ofstream outFile(filename);
    if (!outFile.is_open())
    {
        return -2; // Failed to open file.
    }

    // ===============================
    // 1. Write System Information
    // ===============================
    outFile << "=== System Information ===" << std::endl;
    
    SYSTEM_INFO sysInfo;
    ZeroMemory(&sysInfo, sizeof(SYSTEM_INFO));
    GetSystemInfo(&sysInfo);

    outFile << "Processor Architecture: ";
    switch (sysInfo.wProcessorArchitecture)
    {
        case PROCESSOR_ARCHITECTURE_AMD64:
            outFile << "x64 (AMD or Intel)";
            break;
        case PROCESSOR_ARCHITECTURE_ARM:
            outFile << "ARM";
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            outFile << "Intel Itanium-based";
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            outFile << "x86";
            break;
        default:
            outFile << "Unknown";
            break;
    }
    outFile << std::endl;
    outFile << "Number of Processors: " << sysInfo.dwNumberOfProcessors << std::endl;
    outFile << "Page Size: " << sysInfo.dwPageSize << " bytes" << std::endl;
    outFile << "Minimum Application Address: " << sysInfo.lpMinimumApplicationAddress << std::endl;
    outFile << "Maximum Application Address: " << sysInfo.lpMaximumApplicationAddress << std::endl;

    // Retrieve memory information.
    MEMORYSTATUSEX memStatus;
    memStatus.dwLength = sizeof(MEMORYSTATUSEX);
    if (GlobalMemoryStatusEx(&memStatus))
    {
        outFile << "\n=== Memory Information ===" << std::endl;
        outFile << "Total Physical Memory: " << memStatus.ullTotalPhys / (1024 * 1024) << " MB" << std::endl;
        outFile << "Available Physical Memory: " << memStatus.ullAvailPhys / (1024 * 1024) << " MB" << std::endl;
        outFile << "Total Virtual Memory: " << memStatus.ullTotalVirtual / (1024 * 1024) << " MB" << std::endl;
        outFile << "Available Virtual Memory: " << memStatus.ullAvailVirtual / (1024 * 1024) << " MB" << std::endl;
    }
    else
    {
        outFile << "Error retrieving memory information." << std::endl;
    }

    // ===============================
    // 2. Enumerate Local Users
    // ===============================
    outFile << "\n=== Local Users ===" << std::endl;
    DWORD dwLevel = 0;
    LPUSER_INFO_0 pBuf = nullptr;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD dwResumeHandle = 0;
    NET_API_STATUS nStatus = NetUserEnum(
        nullptr,                    // Local computer (NULL means local).
        dwLevel,                    // Information level.
        FILTER_NORMAL_ACCOUNT,      // Only normal user accounts.
        reinterpret_cast<LPBYTE*>(&pBuf),
        MAX_PREFERRED_LENGTH,
        &dwEntriesRead,
        &dwTotalEntries,
        &dwResumeHandle
    );
    if (nStatus == NERR_Success || nStatus == ERROR_MORE_DATA)
    {
        if (pBuf != nullptr)
        {
            LPUSER_INFO_0 pTmpBuf = pBuf;
            for (DWORD i = 0; i < dwEntriesRead; i++)
            {
                if (pTmpBuf == nullptr)
                    break;
                outFile << "User: " << pTmpBuf->usri0_name << std::endl;
                pTmpBuf++;
            }
        }
        if (pBuf)
            NetApiBufferFree(pBuf);
    }
    else
    {
        outFile << "Failed to enumerate local users. Error: " << nStatus << std::endl;
    }

    // ===============================
    // 3. DNS Query for a Domain
    // ===============================
    outFile << "\n=== DNS Query for hello.iamironcat.com ===" << std::endl;

    // Initialize Winsock (required for DNS functions).
    WSADATA wsaData;
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0)
    {
        outFile << "WSAStartup failed: " << iResult << std::endl;
    }
    else
    {
        PDNS_RECORD pDnsRecord = nullptr;
        DNS_STATUS dnsStatus = DnsQuery_A(
            "hello.iamironcat.com",   // Domain to query.
            DNS_TYPE_A,               // Query for A records.
            DNS_QUERY_STANDARD,       // Standard query options.
            nullptr,                  // Use default DNS server list.
            &pDnsRecord,              // Receives the record list.
            nullptr                   // Reserved.
        );
        if (dnsStatus != 0)
        {
            outFile << "DnsQuery_A failed with error: " << dnsStatus << std::endl;
        }
        else
        {
            bool dnsFound = false;
            PDNS_RECORD pRecord = pDnsRecord;
            while (pRecord != nullptr)
            {
                if (pRecord->wType == DNS_TYPE_A)
                {
                    in_addr ipAddr;
                    ipAddr.s_addr = pRecord->Data.A.IpAddress;
                    outFile << "IP Address: " << inet_ntoa(ipAddr) << std::endl;
                    dnsFound = true;
                }
                pRecord = pRecord->pNext;
            }
            if (!dnsFound)
            {
                outFile << "No A records found for hello.iamironcat.com" << std::endl;
            }
            DnsRecordListFree(pDnsRecord, DnsFreeRecordList);
        }
        WSACleanup();
    }

    outFile.close();
    return 0; // Success.
}

#ifdef __cplusplus
}
#endif
