// net user
// Compile Command: x86_64-w64-mingw32-g++ -o netuser.exe netuser.cpp -static -lnetapi32

#include <windows.h>
#include <lm.h>      // For NetUserEnum and related definitions
#include <iostream>

// Link with the Netapi32.lib library
#pragma comment(lib, "Netapi32.lib")

int main()
{
    // Variables for NetUserEnum call
    DWORD dwLevel = 0;                  // Level 0 returns only username
    LPUSER_INFO_0 pBuf = nullptr;       // Buffer that receives the user information
    DWORD dwEntriesRead = 0;            // Number of entries read
    DWORD dwTotalEntries = 0;           // Total entries available
    DWORD dwResumeHandle = 0;           // For continuing enumeration if necessary
    NET_API_STATUS nStatus;

    // Loop in case more data is available
    do {
        nStatus = NetUserEnum(
            nullptr,                    // Local computer (NULL means local)
            dwLevel,                    // Information level
            FILTER_NORMAL_ACCOUNT,      // Filter out system accounts if desired
            reinterpret_cast<LPBYTE*>(&pBuf), // Buffer to receive data
            MAX_PREFERRED_LENGTH,       // Maximum length of data
            &dwEntriesRead,             // Number of entries read
            &dwTotalEntries,            // Total number of entries available
            &dwResumeHandle             // Resume handle for multiple calls
        );

        // Check if the call was successful or if more data is available
        if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
        {
            if (pBuf != nullptr)
            {
                // pBuf is an array of USER_INFO_0 structures
                LPUSER_INFO_0 pTmpBuf = pBuf;
                for (DWORD i = 0; i < dwEntriesRead; i++)
                {
                    if (pTmpBuf == nullptr)
                        break;

                    // Print the username. Note: usri0_name is a LPWSTR (wide string).
                    std::wcout << L"User: " << pTmpBuf->usri0_name << std::endl;
                    pTmpBuf++;
                }
            }
        }
        else
        {
            std::cerr << "A system error has occurred: " << nStatus << std::endl;
            break;
        }

        // Free the allocated buffer
        if (pBuf != nullptr)
        {
            NetApiBufferFree(pBuf);
            pBuf = nullptr;
        }
    } while (nStatus == ERROR_MORE_DATA);

    return 0;
}
